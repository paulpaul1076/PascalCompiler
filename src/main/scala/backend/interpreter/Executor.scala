package backend.interpreter

import java.io._

import backend.{Backend, BackendFactory}
import backend.interpreter.Executor.{standardIn, standardOut}
import backend.interpreter.executors.CallDeclaredExecutor
import frontend.pascal.PascalScanner
import frontend.{Scanner, Source}
import intermediate.icodeimpl.{ICodeKeyImpl, ICodeNodeTypeImpl}
import intermediate.{ICode, ICodeFactory, SymTabStack}
import message.{Message, MessageType}

/**
  * Interpreter backend.
  */
class Executor extends Backend {

  def this(inputPath: String) {
    this()
    try {
      standardIn = if (inputPath != null) new PascalScanner(
        new Source(
          new BufferedReader(
            new FileReader(inputPath)
          )
        )
      ) else
        new PascalScanner(
          new Source(
            new BufferedReader(
              new InputStreamReader(System.in)
            )
          )
        )

      standardOut = new PrintWriter(new PrintStream(System.out))
    } catch {
      case ignored: IOException => // do nothing, just ignore
    }
    debugger = BackendFactory.createDebugger(DebuggerType.COMMAND_LINE, this, Executor.runtimeStack)
  }

  var debugger: Debugger = _

  def this(parent: Executor) {
    this()
    this.debugger = parent.debugger
    this.messageHandler = parent.messageHandler
  }
  /**
    * Process the intermediate code and the symbol table generated by the parser.
    * To be implemented by a compiler or an interpreter subclass.
    *
    * @param iCode       the intermediate code.
    * @param symTabStack the symbol table.
    */
  override def process(iCode: ICode, symTabStack: SymTabStack): Unit = {
    this.symTabStack = symTabStack
    val startTime = System.currentTimeMillis()

    val programId = symTabStack.getProgramId()

    // Construct an artificial CALL node to the main program.
    val callNode = ICodeFactory.createICodeNode(ICodeNodeTypeImpl.CALL)
    callNode.setAttribute(ICodeKeyImpl.ID, programId)

    // Execute the main program
    val callExecutor = new CallDeclaredExecutor(this)
    callExecutor.execute(callNode)

    val elapsedTime = (System.currentTimeMillis() - startTime) / 1000f
    val runtimeErrors = Executor.errorHandler.getErrorCount

    // Send the interpreter summary message.
    sendMessage(new Message(MessageType.INTERPRETER_SUMMARY, List[Any](Executor.executionCount, runtimeErrors, elapsedTime)))
  }

  /**
    * Getter.
    *
    * @return runtime error handler.
    */
  def getErrorHandler: RuntimeErrorHandler = Executor.errorHandler
}

/**
  * Companion object.
  */
protected object Executor {
  var executionCount = 0
  val runtimeStack = MemoryFactory.createRuntimeStack()
  val errorHandler = new RuntimeErrorHandler

  var standardIn: Scanner = _
  var standardOut: PrintWriter = _
}
