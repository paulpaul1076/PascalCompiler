package backend.compiler

import java.io.{File, PrintStream, PrintWriter}

import backend.Backend
import intermediate.symtabimpl.{DefinitionImpl, Predefined, SymTabKeyImpl}
import intermediate.typeimpl.{TypeFormImpl, TypeKeyImpl}
import intermediate._
import message.{Message, MessageType}

/**
  * Compiler backend.
  */
class CodeGenerator extends Backend {

  var localVariables: LocalVariables
  var localStack: LocalStack
  var assemblyFile: PrintWriter

  def this(parent: CodeGenerator) {
    this()
    this.localStack = parent.localStack
    this.localVariables = parent.localVariables
  }

  /**
   * Process the intermediate code and the symbol table generated by the parser.
   * To be implemented by a compiler or an interpreter subclass.
   *
   * @param iCode  the intermediate code.
   * @param symTabStack the symbol table stack.
   */
  override def process(iCode: ICode, symTabStack: SymTabStack): Unit = {
    this.symTabStack = symTabStack
    val startTime = System.currentTimeMillis()

    val programId = symTabStack.getProgramId()
    CodeGenerator.programName = programId.getName
    val assemblyFileName = CodeGenerator.programName  + ".j"

    // Open a new assembly file for writing.
    assemblyFile = new PrintWriter(
      new PrintStream(
        new File(assemblyFileName)
      )
    )

    // Generate code for the main program.
    val programGenerator = new ProgramGenerator(this)
    programGenerator.generate(iCode.getRoot)
    assemblyFile.close()

    val elapsedTime = (System.currentTimeMillis() - startTime) / 1000f

    sendMessage(new Message(MessageType.COMPILER_SUMMARY, List[Any](CodeGenerator.instructionCount, elapsedTime)))
  }

  /**
    * Generate code for a routine.
    * @param routineId routine id.
    */
  def generate(routineId: SymTabEntry): Unit ={

  }

  /**
    *
    * @param node
    */
  def generate(node: SymTabEntry): Unit = {

  }

  //////
  // General code emitters
  //////

  def emitBlankLine(): Unit ={
    assemblyFile.println()
    assemblyFile.flush()
  }

  ///Labels, they are like GOTO statements

  /**
    * Emit a label.
    *
    * @param label the label.
    */
  def emitLabel(label: Label): Unit = {
    assemblyFile.println(label + ":")
    assemblyFile.flush()
  }

  /**
    * Emit a label preceded by an integer value for a switch table
    *
    * @param value
    * @param label the label.
    */
  def emitLabel(value: Int, label: Label): Unit ={
    assemblyFile.println("\t " + value + ": " + label)
    assemblyFile.flush()
  }

  /**
    * Emit a label preceded by a string value for a switch table.
    *
    * @param value
    * @param label the label.
    */
  def emitLabel(value: String, label: Label): Unit ={
    assemblyFile.println("\t " + value + ": " + label)
    assemblyFile.flush()
  }

  /**
    * Emit no operand directive
    * @param directive
    */
  def emitDirective(directive: Directive): Unit = {
    assemblyFile.println(directive.toString)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }

  /**
    * Emit one operand directive
    * @param directive
    * @param operand
    */
  def emitDirective(directive: Directive, operand: String): Unit = {
    assemblyFile.println(directive.toString + " " + operand)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }

  /**
    * Emit one int operand directive
    * @param directive
    * @param operand
    */
  def emitDirective(directive: Directive, operand: Int): Unit = {
    assemblyFile.println(directive.toString + " " + operand)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }

  /**
    * emit 2 operand directive
    * @param directive
    * @param operand1
    * @param operand2
    */
  def emitDirective(directive: Directive, operand1: String, operand2: String): Unit = {
    assemblyFile.println(directive.toString + " " + operand1 + " " + operand2)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }

  /**
    * Emit 3 operand directive
    * @param directive
    * @param operand1
    * @param operand2
    * @param operand3
    */
  def emitDirective(directive: Directive, operand1: String, operand2: String, operand3: String): Unit = {
    assemblyFile.println(directive.toString + " " + operand1 + " " + operand2 + " " + operand3)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }


  /////////////////////
  //Emit instructions.
  /////////////////////

  def emit(opcode: Instruction): Unit = {
    assemblyFile.println("\t" + opcode.toString)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }

  def emit(opcode: Instruction, operand: String): Unit = {
    assemblyFile.println("\t" + opcode.toString + "\t" + operand)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }

  def emit(opcode: Instruction, operand: Int): Unit = {
    assemblyFile.println("\t" + opcode.toString + "\t" + operand)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }

  def emit(opcode: Instruction, operand: Float): Unit = {
    assemblyFile.println("\t" + opcode.toString + "\t" + operand)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }

  def emit(opcode: Instruction, label: Label): Unit ={
    assemblyFile.println("\t" + opcode.toString + "\t" + label)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }

  def emit(opcode: Instruction, operand1: Int, operand2: Int): Unit = {
    assemblyFile.println("\t" + opcode.toString + "\t" + operand1 + " " + operand2)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }

  def emit(opcode: Instruction, operand1: String, operand2: String): Unit = {
    assemblyFile.println("\t" + opcode.toString + "\t" + operand1 + " " + operand2)
    assemblyFile.flush()
    CodeGenerator.instructionCount += 1
  }

  /////////
  // Loads
  /////////

  def emitLoadConstant(value: Int): Unit = {
    value match{
      case -1 => emit(Instruction.ICONST_M1)
      case 0 => emit(Instruction.ICONST_0)
      case 1 => emit(Instruction.ICONST_1)
      case 2 => emit(Instruction.ICONST_2)
      case 3 => emit(Instruction.ICONST_3)
      case 4 => emit(Instruction.ICONST_4)
      case 5 => emit(Instruction.ICONST_5)

      case _ =>
        if (-128 <= value && value <= 127) {
          emit(Instruction.BIPUSH, value)
        } else if (-32768 <= value && value <= 32767) {
          emit(Instruction.SIPUSH, value)
        } else {
          emit(Instruction.LDC, value)
        }
    }
  }

  def emitLoadConstant(value: Float): Unit = {
    if (value == 0.0f) {
      emit(Instruction.FCONST_0)
    } else if (value == 1.0f) {
      emit(Instruction.FCONST_1)
    } else if (value == 2.0f) {
      emit(Instruction.FCONST_2)
    } else {
      emit(Instruction.LDC, value)
    }
  }

  def emitLoadConstant(value: String): Unit = {
    emit(Instruction.LDC, "\"" + value + "\"")
  }

  def emitLoadLocal(`type`: TypeSpec, index: Int): Unit = {
    var form: TypeForm = null
    var typ = `type`

    if (`type` != null) {
      typ = typ.baseType
      form = typ.getForm
    }

    if (typ == Predefined.integerType ||
      typ == Predefined.booleanType ||
      typ == Predefined.charType ||
      form == TypeFormImpl.ENUMERATION) {

      index match {
        case 0 => emit(Instruction.ILOAD_0)
        case 1 => emit(Instruction.ILOAD_1)
        case 2 => emit(Instruction.ILOAD_2)
        case 3 => emit(Instruction.ILOAD_3)
        case _ => emit(Instruction.ILOAD, index)
      }
    } else if (typ == Predefined.realType) {
      index match {
        case 0 => emit(Instruction.FLOAD_0)
        case 1 => emit(Instruction.FLOAD_1)
        case 2 => emit(Instruction.FLOAD_2)
        case 3 => emit(Instruction.FLOAD_3)
        case _ => emit(Instruction.FLOAD, index)
      }
    } else {
      index match {
        case 0 => emit(Instruction.ALOAD_0)
        case 1 => emit(Instruction.ALOAD_1)
        case 2 => emit(Instruction.ALOAD_2)
        case 3 => emit(Instruction.ALOAD_3)
        case _ => emit(Instruction.ALOAD, index)
      }
    }
  }

  def emitLoadVariable(variableId: SymTabEntry): Unit = {
    val variableType = variableId.getTypeSpec.baseType
    val nestingLevel = variableId.getSymTab.getNestingLevel

    // Program variable
    if (nestingLevel == 1) {
      val programName = symTabStack.getProgramId().getName
      val variableName = variableId.getName
      val name = programName + "/" + variableName

      emit(Instruction.GETSTATIC, name, typeDescriptor(variableType))
    }
    // Wrapped variable
    else if (isWrapped(variableId)) {
      val slot = variableId.getAttribute(SymTabKeyImpl.SLOT).asInstanceOf[Integer]
      emitLoadLocal(null, slot)
      emit(Instruction.GETFIELD, varParmWrapper(variableType) + "/value", typeDescriptor(variableType))
    }
    // Local variable.
    else {
      val slot = variableId.getAttribute(SymTabKeyImpl.SLOT).asInstanceOf[Integer]
      emitLoadLocal(variableType, slot)
    }
  }

  def emitLoadArrayElement(`type`: TypeSpec): Unit = {
    var form: TypeForm = null
    var elmtType = `type`

    if (elmtType != null) {
      elmtType = elmtType.baseType
      form = elmtType.getForm
    }
    // Load a character from a string.
    if (elmtType == Predefined.charType) {
      emit(Instruction.INVOKEVIRTUAL, "java/lang/StringBuilder.charAt(I)C")
    }
    // Load an array element.
    else {
      emit (
        if (elmtType == Predefined.integerType) Instruction.IALOAD
        else if (elmtType == Predefined.realType) Instruction.FALOAD
        else if (elmtType == Predefined.booleanType) Instruction.BALOAD
        else if (elmtType == Predefined.charType) Instruction.CALOAD
        else if (form == TypeFormImpl.ENUMERATION) Instruction.IALOAD
        else Instruction.AALOAD
      )
    }
  }

  //////////
  // Stores
  //////////
  def emitStoreLocal(`type`: TypeSpec, index: Int): Unit = {
    var typ = `type`
    var form: TypeForm = null

    if (typ != null) {
      typ = typ.baseType
      form = typ.getForm
    }

    if (typ == Predefined.integerType || typ == Predefined.booleanType || typ == Predefined.charType || form == TypeFormImpl.ENUMERATION) {
      index match {
        case 0 => emit(Instruction.ISTORE_0)
        case 0 => emit(Instruction.ISTORE_1)
        case 0 => emit(Instruction.ISTORE_2)
        case 0 => emit(Instruction.ISTORE_3)
        case _ => emit(Instruction.ISTORE, index)
      }
    } else if (typ == Predefined.realType) {
      index match {
        case 0 => emit(Instruction.FSTORE_0)
        case 1 => emit(Instruction.FSTORE_1)
        case 2 => emit(Instruction.FSTORE_2)
        case 3 => emit(Instruction.FSTORE_3)
        case _ => emit(Instruction.FSTORE, index)
      }
    } else {
      index match {
        case 0 => emit(Instruction.ASTORE_0)
        case 1 => emit(Instruction.ASTORE_1)
        case 2 => emit(Instruction.ASTORE_2)
        case 3 => emit(Instruction.ASTORE_3)
        case _ => emit(Instruction.ASTORE, index)
      }
    }
  }

  def emitStoreVariable(variableId: SymTabEntry): Unit = {
    val nestingLevel = variableId.getSymTab.getNestingLevel
    val slot = variableId.getAttribute(SymTabKeyImpl.SLOT).asInstanceOf[Integer]
    emitStoreVariable(variableId, nestingLevel, slot)
  }

  def emitStoreVariable(variableId: SymTabEntry, nestingLevel: Int, index: Int): Unit = {
    val variableType = variableId.getTypeSpec

    // Program variable.
    if (nestingLevel == 1) {
      val targetName = variableId.getName
      val programName = symTabStack.getProgramId().getName
      val name = programName + "/" + targetName

      emitRangeCheck(variableType)
      emit(Instruction.PUTSTATIC, name, typeDescriptor(variableType.baseType))
    }
    // Wrapped parameter: Set the wrapper's value field
    else if (isWrapped(variableId)) {
      emitRangeCheck(variableType)
      emit(Instruction.PUTFIELD, varParmWrapper(variableType.baseType) + "/value",typeDescriptor(variableType.baseType))
    }
    //Local variable
    else {
      emitRangeCheck(variableType)
      emitStoreLocal(variableType.baseType, index)
    }
  }

  def emitStoreArrayElement(elmtTypee: TypeSpec): Unit = {
    var elmtType = elmtTypee
    var form: TypeForm = null

    if (elmtType != null) {
      elmtType = elmtType.baseType
      form = elmtType.getForm
    }

    if (elmtType == Predefined.charType) {
      emit(Instruction.INVOKEVIRTUAL, "java/lang/StringBuilder.setCharAt(IC)V")
    } else {
      emit(
        if (elmtType == Predefined.integerType) Instruction.IASTORE
        else if (elmtType == Predefined.realType) Instruction.FASTORE
        else if (elmtType == Predefined.booleanType) Instruction.BASTORE
        else if (elmtType == Predefined.charType) Instruction.CASTORE
        else if (form == TypeFormImpl.ENUMERATION) Instruction.IASTORE
        else Instruction.AASTORE
      )
    }
  }

  def emitCheckCast(`type`: TypeSpec): Unit = {
    var descriptor = typeDescriptor(`type`)

    // Don't bracket the type with L; if it's not an array.
    if (descriptor.charAt(0) == 'L') {
      descriptor = descriptor.substring(1, descriptor.length - 1)
    }

    emit(Instruction.CHECKCAST, descriptor)
  }

  def emitCheckCastClass(`type`: TypeSpec): Unit = {
    var descriptor = javaTypeDescriptor(`type`)

    // Don't bracket the type with L; if it's not an array.
    if (descriptor.charAt(0) == 'L') {
      descriptor = descriptor.substring(1, descriptor.length - 1)
    }

    emit(Instruction.CHECKCAST, descriptor)
  }

  def emitReturnValue(`type`: TypeSpec): Unit = {
    var form: TypeForm = null
    var typ = `type`

    if (typ != null) {
      typ = typ.baseType
      form = typ.getForm
    }

    if (typ == Predefined.integerType ||
    typ == Predefined.booleanType ||
    typ == Predefined.charType ||
    form == TypeFormImpl.ENUMERATION) {
      emit(Instruction.IRETURN)
    }
    else if (typ == Predefined.realType) {
      emit(Instruction.FRETURN)
    } else {
      emit(Instruction.ARETURN)
    }
  }

  def emitRangeCheck(targetType: TypeSpec) : Unit = {
    val min = targetType.getAttribute(TypeKeyImpl.SUBRANGE_MIN_VALUE).asInstanceOf[Integer]
    val max = targetType.getAttribute(TypeKeyImpl.SUBRANGE_MAX_VALUE).asInstanceOf[Integer]

    emit(Instruction.DUP)
    emitLoadConstant(min)
    emitLoadConstant(max)
    emit(Instruction.INVOKESTATIC, "RangeChecker/check(III)V")

    localStack.use(3)
  }

  def isStructured(`type`: TypeSpec) : Boolean = {
    val form = `type`.getForm
    `type`.isPascalString || form == TypeFormImpl.ARRAY || form == TypeFormImpl.RECORD
  }

  def isWrapped(variableId: SymTabEntry): Boolean = {
    val `type` = variableId.getTypeSpec
    val form = `type`.getForm
    val defn = variableId.getDefinition

    // Arrays and records are not wrapped.
    defn == DefinitionImpl.VAR_PARM && form != TypeFormImpl.ARRAY && form != TypeFormImpl.RECORD
  }

  def needsCloning(formalId: SymTabEntry) : Boolean = {
    val `type` = formalId.getTypeSpec
    val form = `type`.getForm
    val defn = formalId.getDefinition

    // Array and records are normally passed by reference
    // and so must be cloned to be passed by value
    defn == DefinitionImpl.VALUE_PARM && (form == TypeFormImpl.ARRAY || form == TypeFormImpl.RECORD)
  }

  def typeDescriptor(id: SymTabEntry): String = {
    val `type` = id.getTypeSpec

    if (`type` != null) {
      if (isWrapped(id)) {
        return "L" + varParmWrapper(`type`.baseType) + ";"
      } else {
        return typeDescriptor(id.getTypeSpec)
      }
    } else {
      return "V"
    }
  }

  def typeDescriptor(`type`: TypeSpec): String = {
    var form = `type`.getForm
    val buffer = new StringBuilder
    var typ = `type`

    while (form == TypeFormImpl.ARRAY && !typ.isPascalString) {
      buffer.append("[")
      typ = typ.getAttribute(TypeKeyImpl.ARRAY_ELEMENT_TYPE).asInstanceOf[TypeSpec]
      form = typ.getForm
    }

    typ = typ.baseType

    if (typ == Predefined.integerType) {
      buffer.append("I")
    } else if (typ == Predefined.realType) {
      buffer.append("F")
    } else if (typ == Predefined.booleanType) {
      buffer.append("Z")
    } else if (typ == Predefined.charType) {
      buffer.append("C")
    } else if (typ.isPascalString) {
      buffer.append("Ljava/lang/StringBuilder;")
    } else if (form == TypeFormImpl.ENUMERATION) {
      buffer.append("I")
    } else /*(form == RECORD)*/ {
      buffer.append("Ljava/util/HashMap;")
    }

    return buffer.toString()
  }

  def javaTypeDescriptor(`type`: TypeSpec): String = {
    var form = `type`.getForm
    val buffer = new StringBuilder
    var isArray = false
    var typ = `type`

    while (form == TypeFormImpl.ARRAY && !typ.isPascalString) {
      buffer.append("[")
      typ = typ.getAttribute(TypeKeyImpl.ARRAY_ELEMENT_TYPE).asInstanceOf[TypeSpec]
      form = typ.getForm
      isArray = true
    }

    if (isArray) {
      buffer.append("L")
    }

    typ = typ.baseType

    if (typ == Predefined.integerType) {
      buffer.append("java/lang/Integer")
    } else if (typ == Predefined.realType) {
      buffer.append("java/lang/Float")
    } else if (typ == Predefined.booleanType) {
      buffer.append("java/lang/Boolean")
    } else if (typ == Predefined.charType) {
      buffer.append("java/lang/Character")
    } else if (typ.isPascalString) {
      buffer.append("java/lang/StringBuilder")
    } else if (form == TypeFormImpl.ENUMERATION) {
      buffer.append("java/lang/Integer")
    } else /*(form == RECORD)*/ {
      buffer.append("java/util/HashMap")
    }

    if (isArray) {
      buffer.append(";")
    }

    buffer.toString()
  }

  def valueOfSignature(`type`: TypeSpec) : String = {
    val javaType = javaTypeDescriptor(`type`)
    val typeCode = typeDescriptor(`type`)

    String.format("%s.valueOf(%s)L%s", javaType, typeCode, javaType)
  }

  def valueSignature(`type`: TypeSpec): String = {
    val javaType = javaTypeDescriptor(`type`)
    val typeCode = typeDescriptor(`type`)
    val typeName = if (`type` == Predefined.integerType) "int"
    else if (`type` == Predefined.realType) "float"
    else if (`type` == Predefined.booleanType) "boolean"
    else if (`type` == Predefined.charType) "char"
    else "int"

    String.format("%s.%sValue()%s", javaType, typeName, typeCode)
  }

  def varParmWrapper(`type`: TypeSpec): String = {
    var typ = `type`.baseType

    val form = typ.getForm

    return if (typ == Predefined.integerType) "IWrap"
            else if (typ == Predefined.realType) "RWrap"
            else if (typ == Predefined.booleanType) "BWrap"
            else if (form == TypeFormImpl.ENUMERATION) "IWrap"
            else "CWrap"
  }
}

object CodeGenerator{
  var assemblyFile: PrintWriter = null
  var instructionCount = 0
  var programName: String = null
}